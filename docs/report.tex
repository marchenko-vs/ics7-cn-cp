\documentclass{bmstu}

\usepackage{biblatex}
\usepackage{array}
\usepackage{amsmath}

\addbibresource{inc/biblio/sources.bib}

\begin{document}

\makecourseworktitle
    {Информатика и системы управления}
    {Программное обеспечение ЭВМ и информационные технологии}
    {Реализация статического веб-сервера для отдачи контента с диска}
    {В.~Марченко/ИУ7-73Б}
    { }
    {}
    
\setcounter{page}{3}

{\centering \chapter*{РЕФЕРАТ}}

Расчетно-пояснительная записка X с., X рис., 3 табл., X источн., 1 прил.

\noindent КОМПЬЮТЕРНЫЕ СЕТИ, СТАТИЧЕСКИЙ СЕРВЕР, ВЕБ-СЕРВЕР, HTTP, NGINX, НАГРУЗОЧНОЕ ТЕСТИРОВАНИЕ, APACHEBENCH

Объектом разработки является статический веб-сервер для отдачи контента с диска.

Объектом исследования является время обработки запросов статическим веб-сервером.

Цель работы: реализация статического веб-сервера для отдачи контента с диска.

В результате выполнения работы был реализован статический веб-сервер для отдачи контента с диска, а также проведено нагрузочное тестирование реализованного сервера.

В ходе проведения исследования было установлено, что сервер nginx обрабатывает запросы в среднем в 2 раза быстрее, чем реализованный статический веб-сервер.

Область применения результатов --- дальнейшее развитие реализованного статического веб-сервера для поддержки отдачи контента различных MIME-типов.

{\centering \maketableofcontents}

{\centering \chapter*{ПЕРЕЧЕНЬ СОКРАЩЕНИЙ И ОБОЗНАЧЕНИЙ}}

В настоящей расчетно-пояснительной записке к курсовой работе применяют следующие сокращения и обозначения:

\begin{table}[H]
\begin{tabular}{p{5cm}p{10.5cm}}
ОС & Операционная система
\tabularnewline
ПО & Программное обеспечение
\tabularnewline
API & Программный интерфейс приложения (англ. Application Programming Interface)
\tabularnewline
CSS & Каскадные таблицы стилей (англ. Cascading Style Sheets)
\tabularnewline
HTML & Язык гипертекстовой разметки (англ. HyperText Markup Language)
\tabularnewline
HTTP & Протокол передачи гипертекста (англ. HyperText Transfer Protocol)
\tabularnewline
URL & Единообразный указатель местонахождения ресурса (англ. Uniform Resource Locator)
\tabularnewline
\end{tabular}
\end{table}

{\centering \chapter*{ВВЕДЕНИЕ}}
\addcontentsline{toc}{chapter}{ВВЕДЕНИЕ}

Понятие <<веб-сервер>> может относиться как к аппаратному, так и к программному обеспечению. 
Или даже к обеим частям, работающим совместно. 
С точки зрения аппаратного обеспечения, веб-сервер --- это компьютер, который хранит файлы сайта (HTML-документы, CSS-стили, JavaScript-файлы, картинки и пр.) и доставляет их на устройство конечного пользователя (веб-браузер и т.~д.). 
Он подключен к сети Интернет и может быть доступен через доменное имя. 
С точки зрения программного обеспечения, веб-сервер включает в себя несколько компонентов, которые контролируют доступ веб-пользователей к размещенным на сервере файлам, как минимум --- это HTTP-сервер. 
HTTP-сервер — это часть программного обеспечения, которая понимает URL-адреса (веб-адреса) и HTTP (протокол, который браузер использует для просмотра веб-страниц)~\cite{MdnWebServer2023}.

Целью курсовой работы является реализация статического веб-сервера для отдачи контента с диска.

Задачи курсовой работы:
\begin{enumerate}
\item[1)] изучить понятие статического веб-сервера;
\item[2)] спроектировать архитектуру статического сервера;
\item[3)] реализовать спроектированный статический веб-сервер для отдачи контента с диска;
\item[4)] провести нагрузочное тестирование при помощи ApacheBench и сравнить реализованный сервер с сервером nginx.
\end{enumerate}

\chapter{Аналитическая часть}

\section{Требования к статическому веб-серверу}

По заданию на курсовую работу к статическому веб-серверу предъявляются следующие требования.
\begin{enumerate}
\item Поддержка GET и HEAD запросов (поддержка статусов 200, 403, 404).
\item Ответ на неподдерживаемые запросы статусом 405.
\item Выставление Content-Type в зависимости от типа файла (поддержка .html, .css, .js, .png, .jpg, .jpeg, .swf, .gif).
\item Корректная передача файлов размером в 100 МБ.
\item Сервер по умолчанию должен возвращать HTML-страницу на выбранную тему с CSS-стилем.
\item Учесть минимальные требования к безопасности статических серверов (предусмотреть ошибку в случае, если адрес будет выходить за корневую директорию сервера).
\item Реализовать логгер.
\item Использовать язык C без сторонних библиотек.
\item Реализовать архитектуру prefork + pselect().
\item Статический веб-сервер должен работать стабильно.
\end{enumerate}

\section{Статический веб-сервер}

На самом базовом уровне, когда браузеру нужен файл, размещенный на веб-сервере, браузер запрашивает его через HTTP-протокол. 
Когда запрос достигает нужного веб-сервера (аппаратное обеспечение), сервер HTTP (программное обеспечение) принимает запрос, находит запрашиваемый документ (если нет, то сообщает об ошибке 404) и отправляет обратно, также через HTTP. 
На рисунке~\ref{img:web-server} показана схема взаимодействия веб-сервера и браузера~\cite{MdnWebServer2023}.

\includeimage
    {web-server}
    {f}
    {H}
    {1\textwidth}
    {Схема взаимодействия веб-сервера и браузера~\cite{MdnWebServer2023}}

Статический веб-сервер, или стек, состоит из компьютера (аппаратное обеспечение) с сервером HTTP (программное обеспечение). 
Это называют <<статикой>>, потому что сервер посылает размещенные файлы в браузер <<как есть>>~\cite{MdnWebServer2023}.

Динамический веб-сервер состоит из статического веб-сервера и дополнительного программного обеспечения, чаще всего сервера приложения и базы данных. 
Его называют <<динамическим>>, потому что сервер приложений изменяет исходные файлы перед отправкой в браузер по HTTP~\cite{MdnWebServer2023}.

Например, для получения итоговой страницы, которую пользователь просматривает в браузере, сервер приложений может заполнить HTML-шаблон данными из базы данных. 
Такие сайты, как MDN или Википедия, состоят из тысяч веб-страниц, но они не являются реальными HTML документами --- лишь несколько HTML-шаблонов и гигантские базы данных. 
Эта структура упрощает и ускоряет сопровождение веб-приложений и доставку контента~\cite{MdnWebServer2023}.

\section{Структура HTTP-сообщений}

HTTP-сообщения --- это обмен данными между сервером и клиентом. 
Есть два типа сообщений: запросы, отправляемые клиентом, чтобы инициировать реакцию со стороны сервера, и ответы от сервера~\cite{MdnHttpMsg2023}.

Сообщения HTTP состоят из текстовой информации в кодировке ASCII, записанной в несколько строк. 
В HTTP/1.1 и более ранних версиях они пересылались в качестве обычного текста. 
В HTTP/2 текстовое сообщение разделяется на фреймы, что позволяет выполнить оптимизацию и повысить производительность~\cite{MdnHttpMsg2023}.

Веб разработчики не создают текстовые сообщения HTTP самостоятельно --- это делает программа, браузер, прокси или веб-сервер. 
Они обеспечивают создание HTTP сообщений через конфигурационные файлы (для прокси и серверов), API (для браузеров) или другие интерфейсы~\cite{MdnHttpMsg2023}.

HTTP запросы и ответы имеют похожую структуру. 
Они состоят из следующих элементов~\cite{MdnHttpMsg2023}.
\begin{enumerate}
\item Стартовая строка, описывающая запрос, или статус (успех или сбой). 
Это всегда одна строка.
\item Произвольный набор HTTP заголовков, определяющий запрос или описывающий тело сообщения.
\item Пустая строка, указывающая, что вся метаинформация отправлена.
\item Произвольное тело, содержащее пересылаемые с запросом данные (например, содержимое HTML-формы ) или отправляемый в ответ документ. 
Наличие тела и его размер определяется стартовой строкой и заголовками HTTP.
\end{enumerate}

Стартовую строку вместе с заголовками сообщения HTTP называют головой запроса, а его данные --- телом~\cite{MdnHttpMsg2023}.

\section{Заголовки HTTP}

Заголовки HTTP позволяют клиенту и серверу отправлять дополнительную информацию с HTTP запросом или ответом. 
В HTTP-заголовке содержится нечувствительное к регистру название, а затем после (:) непосредственно значение. 
Пробелы перед значением игнорируются~\cite{MdnHttpHeaders2023}.

По заданию на курсовую работу требуется выставлять Content-Type в зависимости от типа файла. 
Заголовок-сущность Content-Type используется для того, чтобы определить MIME-тип ресурса. 
В ответах сервера заголовок Content-Type сообщает клиенту, какой будет тип передаваемого контента~\cite{MdnContentType2023}.

Для следующих файлов используется такой Content-Type:
\begin{enumerate}
\item[1)] .html --- text/html;
\item[2)] .css --- text/css;
\item[3)] .js --- text/javascript;
\item[4)] .png --- image/png;
\item[5)] .jpg --- image/jpg;
\item[6)] .jpeg --- image/jpeg;
\item[7)] .jpeg --- image/gif;
\item[8)] .swf --- application/x-shockwave-flash.
\end{enumerate}

\section{Коды HTTP ответов и методы HTTP запросов}

Код ответа (состояния) HTTP показывает, был ли успешно выполнен определенный HTTP запрос. 
Коды сгруппированы в 5 классов~\cite{MdnHttpStatus2023}:
\begin{enumerate}
\item[1)] информационные 100--199;
\item[2)] успешные 200--299;
\item[3)] перенаправления 300--399;
\item[4)] клиентские ошибки 400--499;
\item[5)] серверные ошибки 500--599.
\end{enumerate}

Коды состояния определены в RFC 7231~\cite{RfcStatus2014}.

Исходя из требований к курсовой работе нужно использовать следующие коды ответа:
\begin{enumerate}
\item[1)] 200 --- OK;
\item[2)] 403 --- Forbidden;
\item[3)] 404 --- Not Found;
\item[4)] 405 --- Method Not Allowed.
\end{enumerate}

HTTP определяет множество методов запроса, которые указывают, какое желаемое действие выполнится для данного ресурса. 
Несмотря на то, что их названия могут быть существительными, эти методы запроса иногда называются HTTP глаголами. 
Каждый реализует свою семантику, но каждая группа команд разделяет общие свойства: так, методы могут быть безопасными, идемпотентными или кешируемыми. 
Существует следующие HTTP глаголы~\cite{MdnHttpMethods2023}.
\begin{enumerate}
\item Метод GET запрашивает представление ресурса. 
Запросы с использованием этого метода могут только извлекать данные.
\item HEAD запрашивает ресурс так же, как и метод GET, но без тела ответа.
\item POST используется для отправки сущностей к определенному ресурсу. Часто вызывает изменение состояния или какие-то побочные эффекты на сервере.
\item PUT заменяет все текущие представления ресурса данными запроса.
\item DELETE удаляет указанный ресурс.
\item CONNECT устанавливает <<туннель>> к серверу, определенному по ресурсу.
\item OPTIONS используется для описания параметров соединения с ресурсом.
\item TRACE выполняет вызов возвращаемого тестового сообщения с ресурса.
\item PATCH используется для частичного изменения ресурса.
\end{enumerate}

По заданию на курсовую работу нужно обрабатывать только GET и HEAD методы. 
На все остальные нужно отвечать кодом состояния 405 Method Not Allowed.

\section{Сокеты}

Сокеты --- название программного интерфейса для обеспечения обмена данными между процессами. 
Процессы при таком обмене могут исполняться как на одной ЭВМ, так и на различных ЭВМ, связанных между собой сетью. 
Сокет --- абстрактный объект, представляющий конечную точку соединения~\cite{Sockets2020}.

Каждый процесс может создать слушающий сокет (серверный сокет) и привязать его к какому-нибудь порту операционной системы. 
Слушающий процесс обычно находится в цикле ожидания, то есть просыпается при появлении нового соединения. 
При этом сохраняется возможность проверить наличие соединений на данный момент, установить тайм-аут для операции и т.~д.~\cite{Sockets2020}

Каждый сокет имеет свой адрес. 
ОС семейства UNIX могут поддерживать много типов адресов, но обязательными являются INET-адрес и UNIX-адрес. 
Если привязать сокет к UNIX-адресу, то будет создан специальный файл (файл сокета) по заданному пути, через который смогут общаться любые локальные процессы путем чтения/записи из него. 
Сокеты типа INET доступны из сети и требуют выделения номера порта~\cite{Sockets2020}.

Обычно клиент явно подсоединяется к слушателю, после чего любое чтение или запись через его файловый дескриптор будут передавать данные между ним и сервером. 
Все сокеты обычно ориентированы на применение датаграмм, но их точные характеристики зависят от интерфейса, обеспечиваемого протоколом~\cite{Sockets2020}. 

\pagebreak
Обмен между сокетами происходит по схеме, изображенной на рисунке~\ref{img:sockets}.

\includeimage
    {sockets}
    {f}
    {H}
    {.5\textwidth}
    {Схема обмена между сокетами~\cite{Sockets2020}}

\pagebreak
\section{Диаграмма вариантов использования}

На рисунке~\ref{img:use-case} показана диаграмма вариантов использования для пользователей статического веб-сервера.

\includeimage
    {use-case}
    {f}
    {H}
    {.7\textwidth}
    {Взаимодействие пользователя со статическим веб-сервером}

\section*{Вывод из аналитической части}

В ходе выполнения аналитической части курсовой работы был проведен анализ предметной области --- изучено понятие статического веб-сервера, сформулированы требования к серверу и описаны пользовательские сценарии в виде диаграммы вариантов использования.

\chapter{Конструкторская часть}

\section{Описание инициализации сервера}

На рисунке~\ref{img:init-server} показана схема инициализации сервера. 

\includeimage
    {init-server}
    {f}
    {H}
    {.2\textwidth}
    {Схема инициализации сервера}
    
\pagebreak
\section{Описание проверки готовности клиентских сокетов}
    
На рисунке~\ref{img:pselect} показана схема проверки готовности клиентских сокетов.

\includeimage
    {pselect}
    {f}
    {H}
    {.5\textwidth}
    {Схема проверки готовности клиентских сокетов}

\pagebreak
\section{Описание обработки HTTP запросов}

На рисунке~\ref{img:process-requests} показана схема обработки HTTP запросов.

\includeimage
    {process-requests}
    {f}
    {H}
    {.7\textwidth}
    {Схема обработки HTTP запросов}

\section*{Вывод из конструкторской части}

В ходе выполнения конструкторской части куросовой работы были описаны в виде схем алгоритмов инициализация сервера, проверка готовности клиентских сокетов и процесс обработки пользовательских HTTP запросов.

\chapter{Технологическая часть}

\section{Средства реализации}

Для реализации статического веб-сервера для отдачи контента с диска использовался язык C (требование к курсовой работе). 
Сервер написан под операционные системы, работающие на базе ядра Linux. 
Для реализации архитектуры prefork + pselect() использовались системные вызовы fork() и pselect(). 
Для инициализации сервера использовались системные вызовы socket(), bind(), listen() и accept(). 
Для чтения запросов и записи ответов использовались системные вызовы recvfrom() и sendto().
Для подготовки тестовых данных (контента для отдачи с диска) были использованы HTML, CSS и JavaScript.

\section{Реализация инициализации сервера}

В листинге~\ref{lst:init-server.c} показана реализация инициализации сервера. 
Сначала выполняется системный вызов socket(), и создается конечная точка соединения. 
Затем заполняются поля структуры struct sockaddr\_in. 
Далее с помощью bind() к сокету server\_socket привязывается локальный адрес server\_address. 
После этого с использованием системного вызова listen() выражается готовность сервера принимать входящие соединения.

\includelisting
	{init-server.c}
	{Реализация инициализации сервера}

\section{Реализация выставления Content-Type}

В листинге~\ref{lst:content-type.c} показана реализация выставления Content-Type в зависимости от типа файла.

\includelisting
	{content-type.c}
	{Реализация выставления Content-Type}
	
\section{Реализация записи содержимого файла в сокет клиента}

В листинге~\ref{lst:send-data.c} показана реализация записи содержимого файла в сокет клиента.

\includelisting
	{send-data.c}
	{Реализация записи содержимого файла в сокет клиента}

\section{Реализация логгера}

В листинге~\ref{lst:logger.c} показана реализация функций для использования логгера.

\includelisting
	{logger.c}
	{Реализация логгера}

\section*{Вывод из технологической части}

В ходе выполнения технологической части курсовой работы были выбраны средства реализации программного обеспечения и написан исходный код статического веб-сервера для отдачи контента с диска.

\chapter{Исследовательская часть}

\section{Технические характеристики устройства}

Технические характеристики устройства, на котором было проведено нагрузочное тестирование:

\begin{enumerate}
\item[1)]
операционная система Ubuntu 22.04.3 LTS;
\item[2)]
оперативная память 4 ГБ;
\item[3)]
процессор Intel\textregistered ~Core\texttrademark ~i7-4790K @ 4.00 ГГц;
\item[4)] версия ядра Linux 6.2.0.
\end{enumerate}

Нагрузочное тестирование проводилось с использованием утилиты ApacheBench --- однопоточной программы для командной строки, используемой для измерения производительности HTTP веб-серверов. 
Тестированое проводилось для сконфигурированного сервера nginx и реализованного статического веб-сервера.

\section{Нагрузочное тестирование}

В таблицах~\ref{tabular:test-nginx}--\ref{tabular:test-server-10} приведены результаты нагрузочного тестирования для сервера nginx и реализованного статического веб-сервера с 1-м дочерним процессом и 10-ю дочерними процессами.

\begin{table}[H]
\caption{Результаты нагрузочного тестирования для сервера nginx}
\label{tabular:test-nginx}
\begin{tabular}{|>{\raggedleft}p{6cm}|>{\raggedleft}p{1.5cm}|>{\raggedleft}p{1.5cm}|>{\raggedleft}p{1.5cm}|>{\raggedleft}p{1.5cm}|>{\raggedleft}p{1.5cm}|}
\hline
\textbf{Кол-во запросов} & 2000 & 4000 & 6000 & 8000 & 10000
\tabularnewline
\hline
\textbf{Общее время тестирования, с} & 0.35 & 1.017 & 1.592 & 2.488 & 2.878
\tabularnewline
\hline
\textbf{Среднее кол-во запросов в секунду} & 5716.25 & 3933.3 & 3769.14 & 3214.81 & 3474.07
\tabularnewline
\hline
\textbf{Среднее время выполнения одного запроса, мс} & 0.175 & 0.254 & 0.265 & 0.311 & 0.288
\tabularnewline
\hline
\textbf{Наибольшее время выполнения запроса, мс} & 14 & 19 & 15 & 22 & 29
\tabularnewline
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\caption{Результаты нагрузочного тестирования для реализованного сервера с 1-м дочерним процессом}
\label{tabular:test-server-1}
\begin{tabular}{|>{\raggedleft}p{6cm}|>{\raggedleft}p{1.5cm}|>{\raggedleft}p{1.5cm}|>{\raggedleft}p{1.5cm}|>{\raggedleft}p{1.5cm}|>{\raggedleft}p{1.5cm}|}
\hline
\textbf{Кол-во запросов} & 2000 & 4000 & 6000 & 8000 & 10000
\tabularnewline
\hline
\textbf{Общее время тестирования, с} & 0.952 & 1.914 & 2.769 & 3.438 & 4.673
\tabularnewline
\hline
\textbf{Среднее кол-во запросов в секунду} & 2100.37 & 2089.91 & 2166.89 & 2327.05 & 2139.94
\tabularnewline
\hline
\textbf{Среднее время выполнения одного запроса, мс} & 0.476 & 0.478 & 0.461 & 0.43 & 0.467
\tabularnewline
\hline
\textbf{Наибольшее время выполнения запроса, мс} & 23 & 22 & 20 & 26 & 33
\tabularnewline
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\caption{Результаты нагрузочного тестирования для реализованного сервера с 10-ю дочерними процессами}
\label{tabular:test-server-10}
\begin{tabular}{|>{\raggedleft}p{6cm}|>{\raggedleft}p{1.5cm}|>{\raggedleft}p{1.5cm}|>{\raggedleft}p{1.5cm}|>{\raggedleft}p{1.5cm}|>{\raggedleft}p{1.5cm}|}
\hline
\textbf{Кол-во запросов} & 2000 & 4000 & 6000 & 8000 & 10000
\tabularnewline
\hline
\textbf{Общее время тестирования, с} & 1.107 & 1.644 & 2.333 & 2.908 & 3.426
\tabularnewline
\hline
\textbf{Среднее кол-во запросов в секунду} & 1806.29 & 2432.94 & 2571.27 & 2750.87 & 2918.62
\tabularnewline
\hline
\textbf{Среднее время выполнения одного запроса, мс} & 0.554 & 0.411 & 0.389 & 0.364 & 0.343
\tabularnewline
\hline
\textbf{Наибольшее время выполнения запроса, мс} & 24 & 22 & 28 & 25 & 19
\tabularnewline
\hline
\end{tabular}
\end{table}

\pagebreak
На рисунке~\ref{img:graph-01} показана зависимость общего времени нагрузочного тестирования в секундах от количества запросов.

\includeimage
    {graph-01}
    {f}
    {H}
    {0.7\textwidth}
    {Зависимость общего времени нагрузочного тестирования от количества запросов}
    
На рисунке~\ref{img:graph-02} показана зависимость среднего времени выполнения запроса в миллисекундах от количества запросов.

\includeimage
    {graph-02}
    {f}
    {H}
    {0.7\textwidth}
    {Зависимость среднего времени выполнения запроса в миллисекундах от количества запросов}

\section*{Вывод из исследовательской части}

В ходе выполнения исследовательской части было проведено нагрузочное тестирование сервера nginx и реализованного сервера с 1-м дочерним процессом и 10-ю дочерними процессами. 
Согласно полученным данным, быстрее всего работает сервер nginx. 
Он обрабатывает запросы в среднем в 2 раза быстрее, чем реализованный статический сервер. 
Однако за счет увеличения количества дочерних процессов можно увеличить скорость обработки запросов реализованным веб-сервером.

{\centering \chapter*{ЗАКЛЮЧЕНИЕ}}
\addcontentsline{toc}{chapter}{ЗАКЛЮЧЕНИЕ}

В результате выполнения курсовой работы был реализован статический веб-сервера для отдачи контента с диска.

Были выполнены следующие задачи:
\begin{enumerate}
\item[1)] изучено понятие статического веб-сервера;
\item[2)] спроектирована архитектура статического сервера;
\item[3)] реализован спроектированный статический веб-сервер для отдачи контента с диска;
\item[4)] проведено сравнение результатов нагрузочного тестирования (при помощи ApacheBench) реализованного сервера с сервером nginx.
\end{enumerate}

В ходе проведения исследования было выявлено, что сервер nginx обрабатывает запросы в среднем в 2 раза быстрее, чем реализованный статический веб-сервер с 1-м дочерним процессом. 
При 10 дочерних процессах статический веб-сервер обрабатывает запросы на 16\% медленнее, чем nginx (для 10 тысяч запросов).

{\centering \printbibliography[title=СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ,heading=bibintoc]}

{\centering \chapter*{ПРИЛОЖЕНИЕ А}}
\addcontentsline{toc}{chapter}{ПРИЛОЖЕНИЕ А Исходный код программы}
\begin{center}
\textbf{Исходный код программы}
\end{center}

В листингах~\ref{lst:main.c}--\ref{lst:logger-impl.c} показан исходный код реализованного статического веб-сервера для отдачи контента с диска.

\includelisting
	{main.c}
	{Файл main.c}
	
\includelisting
	{server.h}
	{Файл server.h}
	
\includelisting
	{server.c}
	{Файл server.c}
	
\includelisting
	{logger.h}
	{Файл logger.h}
	
\includelisting
	{logger-impl.c}
	{Файл logger.c}

\end{document}
