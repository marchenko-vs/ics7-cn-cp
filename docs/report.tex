\documentclass{bmstu}

\usepackage{biblatex}
\usepackage{array}
\usepackage{amsmath}

\addbibresource{inc/biblio/sources.bib}

\begin{document}

\makecourseworktitle
    {Информатика и системы управления}
    {Программное обеспечение ЭВМ и информационные технологии}
    {Реализация статического веб-сервера для отдачи контента с диска}
    {В.~Марченко/ИУ7-73Б}
    {Е.~А.~Тихомирова}
    {}
    
\setcounter{page}{3}

{\centering \chapter*{РЕФЕРАТ}}

Расчетно-пояснительная записка X с., X рис., X табл., X источн., X прил.

\noindent КОМПЬЮТЕРНЫЕ СЕТИ, СТАТИЧЕСКИЙ СЕРВЕР, ВЕБ-СЕРВЕР, HTTP

Объектом разработки является статический веб-сервер для отдачи контента с диска.

Объектом исследования является ...

Цель работы: реализация статического веб-сервера для отдачи контента с диска.

В результате выполнения работы была реализован статический веб-сервер для отдачи контента с диска.

В ходе проведения исследования было установлено, что ...

Область применения результатов --- ...

{\centering \maketableofcontents}

{\centering \chapter*{ПЕРЕЧЕНЬ СОКРАЩЕНИЙ И ОБОЗНАЧЕНИЙ}}

В настоящей расчетно-пояснительной записке к курсовой работе применяют следующие сокращения и обозначения:

\begin{table}[H]
\begin{tabular}{p{5cm}p{10.5cm}}
ПО & Программное обеспечение
\tabularnewline
\end{tabular}
\end{table}

{\centering \chapter*{ВВЕДЕНИЕ}}
\addcontentsline{toc}{chapter}{ВВЕДЕНИЕ}

Целью курсовой работы является реализация статического веб-сервера для отдачи контента с диска.

Задачами данной работы являются:
\begin{enumerate}
\item[1)] изучить понятие статического веб-сервера;
\item[2)] спроектировать архитектуру статического веб-сервера;
\item[3)] реализовать спроектированный статический веб-сервер для отдачи контента с диска;
\item[4)] провести нагрузочное тестирования при помощи apache benchmark с nginx.
\end{enumerate}

\chapter{Аналитическая часть}

\section{Статический веб-сервер}

Понятие <<веб-сервер>> может относиться как к аппаратному, так и к программному обеспечению. 
Или даже к обеим частям, работающим совместно. 
С точки зрения аппаратного обеспечения, веб-сервер --- это компьютер, который хранит файлы сайта (HTML-документы, CSS-стили, JavaScript-файлы, картинки и пр.) и доставляет их на устройство конечного пользователя (веб-браузер и т.~д.). 
Он подключен к сети Интернет и может быть доступен через доменное имя. 
С точки зрения программного обеспечения, веб-сервер включает в себя несколько компонентов, которые контролируют доступ веб-пользователей к размещенным на сервере файлам, как минимум --- это HTTP-сервер. 
HTTP-сервер — это часть программного обеспечения, которая понимает URL-адреса (веб-адреса) и HTTP (протокол, который браузер использует для просмотра веб-страниц)~\cite{MdnWebServer2023}.

На самом базовом уровне, когда браузеру нужен файл, размещенный на веб-сервере, браузер запрашивает его через HTTP-протокол. 
Когда запрос достигает нужного веб-сервера (аппаратное обеспечение), сервер HTTP (программное обеспечение) принимает запрос, находит запрашиваемый документ (если нет, то сообщает об ошибке 404) и отправляет обратно, также через HTTP. 
На рисунке~\ref{img:web-server} показана схема взаимодействия веб-сервера и браузера~\cite{MdnWebServer2023}.

\includeimage
    {web-server}
    {f}
    {H}
    {1\textwidth}
    {Схема взаимодействия веб-сервера и браузера~\cite{MdnWebServer2023}}

Статический веб-сервер, или стек, состоит из компьютера (аппаратное обеспечение) с сервером HTTP (программное обеспечение). 
Это называют <<статикой>>, потому что сервер посылает размещенные файлы в браузер <<как есть>>~\cite{MdnWebServer2023}.

Динамический веб-сервер состоит из статического веб-сервера и дополнительного программного обеспечения, чаще всего сервера приложения и базы данных. 
Его называют <<динамическим>>, потому что сервер приложений изменяет исходные файлы перед отправкой в браузер по HTTP~\cite{MdnWebServer2023}.

Например, для получения итоговой страницы, которую пользователь просматривает в браузере, сервер приложений может заполнить HTML-шаблон данными из базы данных. 
Такие сайты, как MDN или Википедия, состоят из тысяч веб-страниц, но они не являются реальными HTML документами --- лишь несколько HTML-шаблонов и гигантские базы данных. 
Эта структура упрощает и ускоряет сопровождение веб-приложений и доставку контента~\cite{MdnWebServer2023}.

\section{Структура HTTP-сообщений}

HTTP сообщения --- это обмен данными между сервером и клиентом. 
Есть два типа сообщений: запросы, отправляемые клиентом, чтобы инициировать реакцию со стороны сервера, и ответы от сервера~\cite{MdnHttpMsg2023}.

Сообщения HTTP состоят из текстовой информации в кодировке ASCII, записанной в несколько строк. 
В HTTP/1.1 и более ранних версиях они пересылались в качестве обычного текста. 
В HTTP/2 текстовое сообщение разделяется на фреймы, что позволяет выполнить оптимизацию и повысить производительность~\cite{MdnHttpMsg2023}.

Веб разработчики не создают текстовые сообщения HTTP самостоятельно --- это делает программа, браузер, прокси или веб-сервер. 
Они обеспечивают создание HTTP сообщений через конфигурационные файлы (для прокси и серверов), APIs (для браузеров) или другие интерфейсы~\cite{MdnHttpMsg2023}.

HTTP запросы и ответы имеют близкую структуру. 
Они состоят из следующих элементов~\cite{MdnHttpMsg2023}.
\begin{enumerate}
\item Стартовая строка, описывающая запрос, или статус (успех или сбой). 
Это всегда одна строка.
\item Произвольный набор HTTP заголовков, определяющий запрос или описывающий тело сообщения.
\item Пустая строка, указывающая, что вся мета информация отправлена.
\item Произвольное тела, содержащее пересылаемые с запросом данные (например, содержимое HTML-формы ) или отправляемый в ответ документ. 
Наличие тела и его размер определяется стартовой строкой и заголовками HTTP.
\end{enumerate}

Стартовую строку вместе с заголовками сообщения HTTP называют головой запроса, а его данные --- телом~\cite{MdnHttpMsg2023}.

\section{Сокеты}

Сокеты (англ. socket --- разъем) --- название программного интерфейса для обеспечения обмена данными между процессами. 
Процессы при таком обмене могут исполняться как на одной ЭВМ, так и на различных ЭВМ, связанных между собой сетью. 
Сокет --- абстрактный объект, представляющий конечную точку соединения~\cite{Sockets2020}.

Каждый процесс может создать слушающий сокет (серверный сокет) и привязать его к какому-нибудь порту операционной системы. 
Слушающий процесс обычно находится в цикле ожидания, то есть просыпается при появлении нового соединения. 
При этом сохраняется возможность проверить наличие соединений на данный момент, установить тайм-аут для операции и т.~д~\cite{Sockets2020}.

Каждый сокет имеет свой адрес. 
ОС семейства UNIX могут поддерживать много типов адресов, но обязательными являются INET-адрес и UNIX-адрес. 
Если привязать сокет к UNIX-адресу, то будет создан специальный файл (файл сокета) по заданному пути, через который смогут сообщаться любые локальные процессы путем чтения/записи из него. 
Сокеты типа INET доступны из сети и требуют выделения номера порта~\cite{Sockets2020}.

Обычно клиент явно подсоединяется к слушателю, после чего любое чтение или запись через его файловый дескриптор будут передавать данные между ним и сервером~\cite{Sockets2020}.

Все сокеты обычно ориентированы на применение датаграмм, но их точные характеристики зависят от интерфейса, обеспечиваемого протоколом. 
Обмен между сокетами происходит по схеме, изображенной на рисунке~\ref{img:sockets}:

\includeimage
    {sockets}
    {f}
    {H}
    {.5\textwidth}
    {Схема обмена между сокетами}

\section{Требования к статическому веб-серверу}

По заданию на курсовую работу к статическому веб-серверу предъявляются следующие требования.
\begin{enumerate}
\item Поддержка GET и HEAD запросов (поддержка статусов 200, 403, 404).
\item Ответ на неподдерживаемые запросы статусом 405.
\item Выставление content-type в зависимости от типа файла (поддержка .html, .css, .js, .png, .jpg, .jpeg, .swf, .gif).
\item Корректная передача файлов размером в 100 МБ.
\item Сервер по умолчанию должен возвращать HTML-страницу на выбранную тему с CSS-стилем.
\item Учесть минимальные требования к безопасности статических серверов (предусмотреть ошибку в случае если адрес будет выходить за корневую директорию сервера).
\item Реализовать логгер.
\item Использовать язык C без сторонних библиотек.
\item Реализовать архитектуру prefork + pselect().
\item Статический веб-сервер должен работать стабильно.
\end{enumerate}

\section{Диаграмма вариантов использования}

На рисунке~\ref{img:use-case} показана use case диаграмма для пользователей статического веб-сервера.

\includeimage
    {use-case}
    {f}
    {H}
    {1\textwidth}
    {Взаимодействие пользователя со статическим веб-сервером}

\section*{Вывод из аналитической части}

В ходе выполнения аналитической части курсовой работы был проведен анализ предметной области --- изучено понятие статического веб-сервера, сформулированы требования к серверу и описаны пользовательские сценарии в виде use case диаграммы.

\chapter{Конструкторская часть}

\section{Описание обработки HTTP-запросов}

На рисунке~\ref{img:process-requests} показана схема обработки HTTP-запросов.

\includeimage
    {process-requests}
    {f}
    {H}
    {.7\textwidth}
    {Схема обработки HTTP-запросов}
    
\section{Описание запуска и настройки сервера}    

\section{Описание логгирования}

\section*{Вывод из конструкторской части}

В ходе выполнения конструкторской части куросовой работы была создана диграмма базы данных; описаны сущности базы данных; описаны проектируемые ограничения целостности базы данных; описана функция на уровне базы данных, которая считает стоимость заказа, в виде схемы алгоритма и описана проектируемая ролевая модель на уровне базы данных, которая состоит из трех ролей --- клиент, модератор и администратор.

\chapter{Технологическая часть}

\section{Средства реализации}

Для реализации статического веб-сервера был использован язык C (требование к курсовой работе). 
Сервер написан под операционные системы, работающие на базе ядра Linux. 
Для реализации архитектуры prefork + pselect() использовались системные вызовы fork() и pselect(). 
Для подготовки тестовых данных (контента для отдачи с диска) были использованы HTML, CSS и JavaScript.

\section{Реализация обработки запросов}

\section{Реализация логгера}

\section*{Вывод из технологической части}

В ходе выполнения технологической части курсовой работы были выбраны средства реализации программного обеспечения; написан исходный код сущностей, ограничений целостности, проектируемой функции, ролевой модели базы данных; реализован интерфейс доступа к базе данных и протестирован разработанный функционал.

\chapter{Исследовательская часть}

\section{Технические характеристики устройства}

Технические характеристики устройства, на котором было проведено нагрузочное тестирование:

\begin{enumerate}
\item[1)]
операционная система Linux Ubuntu;
\item[2)]
оперативная память 4 ГБ;
\item[3)]
процессор Intel\textregistered ~Core\texttrademark ~i7-4790K @ 4.00 ГГц.
\end{enumerate}

Нагрузочное тестирование проводилось с использованием утилиты apache benchmark.

\section{Нагрузочное тестирование}

В таблице~\ref{tabular:results} приведены результаты нагрузочного тестирования.

\begin{table}[H]
\caption{Результаты нагрузочного тестирования}
\label{tabular:results}
\begin{tabular}{|>{\raggedleft}p{2cm}|>{\raggedleft}p{4cm}|>{\raggedleft}p{4cm}|>{\raggedleft}p{4cm}|}
\hline
\textbf{Кол-во строк} & \textbf{Время выполнения запроса без индекса, мс} & \textbf{Время выполнения запроса с кластеризованным индексом, мс} & \textbf{Время выполнения запроса с некластеризованным индексом, мс}
\tabularnewline
\hline
100 & 468 & 440 & 450
\tabularnewline
\hline
1000 & 471 & 421 & 439
\tabularnewline
\hline
10000 & 510 & 425 & 445
\tabularnewline
\hline
50000 & 757 & 414 & 453
\tabularnewline
\hline
100000 & 1642 & 472 & 460
\tabularnewline
\hline
250000 & 10701 & 498 & 510
\tabularnewline
\hline
\end{tabular}
\end{table}

\section*{Вывод из исследовательской части}

В ходе выполнения исследовательской части курсовой работы был проведен краткий обзор кластеризованных и некластеризованных индексов; определены таблицы и атрибуты, для которых имеет смысл создавать индексы, и проведен эксперимент по измерению времени выполнения запроса без индекса, с кластеризованным и некластеризованным индексом. 
Согласно полученным при проведении эксперимента данным, при количестве строк в таблице до 10 тысяч существенной разницы во времени выполнения запроса не наблюдается. 
При большем количестве записей время выполнения запроса без использования индекса растет в разы быстрее, а время выполнения запроса с использованием двух типов индексов остается практически неизменным. 
Разница во времени выполнения запроса с кластеризованным и некластеризованным индексом практически отсутствует. 
При 250 тысячах строк в таблице использование индекса увеличивает скорость выполнения запроса в 21 раз при поиске первой записи и в 97 раз при поиске последней.

{\centering \chapter*{ЗАКЛЮЧЕНИЕ}}
\addcontentsline{toc}{chapter}{ЗАКЛЮЧЕНИЕ}

В результате выполнения курсовой работы был реализован статический веб-сервера для отдачи контента с диска.

Были выполнены следующие задачи:
\begin{enumerate}
\item[1)] изучено понятие статического веб-сервера;
\item[2)] спроектирована архитектуру статического веб-сервера;
\item[3)] реализован спроектированный статический веб-сервер для отдачи контента с диска;
\item[4)] проведено нагрузочное тестирования при помощи apache benchmark с nginx.
\end{enumerate}

В ходе проведения исследования было выявлено...

{\centering \printbibliography[title=СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ,heading=bibintoc]}

{\centering \chapter*{ПРИЛОЖЕНИЕ А}}
\addcontentsline{toc}{chapter}{ПРИЛОЖЕНИЕ А Презентация}
\center{\textbf{Презентация}}

\end{document}
